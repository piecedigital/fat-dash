{"version":3,"sources":["domain/csv-etl/parse.ts","domain/csv-etl/map-raw-csv-to-record.ts","domain/csv-etl/csv-record-map-props.ts","../node_modules/@babel/runtime/helpers/isNativeFunction.js","../node_modules/@babel/runtime/helpers/construct.js","../node_modules/@babel/runtime/helpers/wrapNativeSuper.js","domain/csv-etl/ChallengeCreateError.ts","domain/csv-etl/validate-csv.ts","domain/csv-etl/mapWeaponsFromFile.ts","domain/csv-etl/createChallenge.ts","common/async.ts","app/createChallengeWorker.ts"],"names":[],"mappings":"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","file":"createChallengeWorker.b6dce7cb.js","sourceRoot":"..\\src","sourcesContent":["import { parseIntOrThrow } from \"../util/number\"\r\nimport {\r\n  ChallengeFileName,\r\n  CsvRawSections\r\n} from \"@fat-dash/domain/csv-etl/types\"\r\nimport { parseCsv } from \"@fat-dash/ccc\"\r\n\r\nfunction parseChallengeFileNameOrThrow(name: string): ChallengeFileName {\r\n  const match = REGEX.exec(name)\r\n  if (!match) {\r\n    throw new Error(ERR_MSG)\r\n  } else {\r\n    const scenario = match[1]\r\n    const year = parseIntOrThrow(match[2], `year in ${name}`)\r\n\r\n    // convert given month to number between 0 and 11 (js spec)\r\n    const month = parseIntOrThrow(match[3], `month in ${name}`) - 1\r\n\r\n    const day = parseIntOrThrow(match[4], `day in ${name}`)\r\n    const hours = parseIntOrThrow(match[5], `hours in ${name}`)\r\n    const minutes = parseIntOrThrow(match[6], `minutes in ${name}`)\r\n    const seconds = parseIntOrThrow(match[7], `seconds in ${name}`)\r\n\r\n    // file name is local date, so use date without Date.UTC\r\n    const date = new Date(year, month, day, hours, minutes, seconds)\r\n\r\n    return { scenario, mode: \"Challenge\", full: name, date: date }\r\n  }\r\n}\r\n\r\n// e.g. RexStrafesCata - Challenge - 2018.08.05-00.31.16 Stats.csv\r\nconst REGEX = /^(.*?)\\s-\\sChallenge\\s-\\s(\\d{4})\\.(\\d{2})\\.(\\d{2})-(\\d{2})\\.(\\d{2})\\.(\\d{2})\\sStats.csv$/\r\n\r\nconst ERR_MSG = `Invalid file name, given ${name}. Did you try to import \\\r\n something other than a challenge (free to play mode, ...)?`\r\n\r\nfunction parseCsvSections(rawCsvContent: string): CsvRawSections {\r\n  const out: CsvRawSections = []\r\n  let currentSectionIndex = 0\r\n\r\n  parseCsv(rawCsvContent).forEach(row => {\r\n    if (row.length && row[0]) {\r\n      out[currentSectionIndex] = out[currentSectionIndex] || []\r\n      out[currentSectionIndex].push(row)\r\n    } else currentSectionIndex += 1\r\n  })\r\n  return out\r\n}\r\n\r\nexport { parseChallengeFileNameOrThrow, parseCsvSections }\r\n","import { PrimitiveLike } from \"@fat-dash/ui/form-chart-widget-kit/types\";\r\n\r\nconst mapCsvContentWithHeader = (section: any[][], propertyNames: string[]) => {\r\n  const data: Array<{ [key: string]: PrimitiveLike }> = []\r\n  section.forEach((dataRow, index) => {\r\n    if (index !== 0) {\r\n      data.push(dataRowToObj(dataRow, propertyNames))\r\n    }\r\n  })\r\n  return data\r\n\r\n  function dataRowToObj(csvDataRow: any[], _propertyNames: string[]) {\r\n    const out: { [key: string]: PrimitiveLike } = {}\r\n    return csvDataRow.reduce((accObj, cellValue, idx) => {\r\n      accObj[_propertyNames[idx]] = cellValue\r\n      return accObj\r\n    }, out)\r\n  }\r\n}\r\n\r\nconst mapKeyValueCsvContent = (section: any[][], propertyNames: string[]) => {\r\n  const record: { [key: string]: PrimitiveLike } = {}\r\n  // convert key value section to single entity\r\n  section.forEach((dataRow, index) => {\r\n    record[propertyNames[index]] = dataRow[1]\r\n  })\r\n  return record\r\n}\r\n\r\nexport { mapCsvContentWithHeader, mapKeyValueCsvContent }\r\n","import {\r\n  CsvTechnicalStatsRecord,\r\n  CsvSummaryStatsRecord,\r\n  CsvKillStatsRecord,\r\n  CsvWeaponStatsRecord\r\n} from \"./csv-record-types\"\r\nimport {\r\n  mapKeyValueCsvContent,\r\n  mapCsvContentWithHeader\r\n} from \"./map-raw-csv-to-record\"\r\nimport {\r\n  technicalPropertyNames,\r\n  summaryPropertyNames,\r\n  killPropertyNames,\r\n  weaponPropertyNames\r\n} from \"./version/version-api\"\r\nimport { GameVersion } from \"./version/version-types\"\r\n\r\nconst mapCsvTechnicalStatsRecord = (\r\n  technicalSection: any[][],\r\n  gameVersion: GameVersion\r\n) =>\r\n  mapKeyValueCsvContent(\r\n    technicalSection,\r\n    technicalPropertyNames(gameVersion)\r\n  ) as CsvTechnicalStatsRecord\r\n\r\nconst mapCsvSummaryStatsRecord = (\r\n  summarySection: any[][],\r\n  gameVersion: GameVersion\r\n) =>\r\n  mapKeyValueCsvContent(\r\n    summarySection,\r\n    summaryPropertyNames(gameVersion)\r\n  ) as CsvSummaryStatsRecord\r\n\r\nconst mapCsvKillStatsRecords = (\r\n  killSection: any[][],\r\n  gameVersion: GameVersion\r\n) =>\r\n  mapCsvContentWithHeader(\r\n    killSection,\r\n    killPropertyNames(gameVersion)\r\n  ) as CsvKillStatsRecord[]\r\n\r\nconst mapCsvWeaponStatsRecord = (\r\n  weaponSection: any[][],\r\n  gameVersion: GameVersion\r\n) =>\r\n  mapCsvContentWithHeader(\r\n    weaponSection,\r\n    weaponPropertyNames(gameVersion)\r\n  ) as CsvWeaponStatsRecord[]\r\n\r\nexport {\r\n  mapCsvWeaponStatsRecord,\r\n  mapCsvKillStatsRecords,\r\n  mapCsvSummaryStatsRecord,\r\n  mapCsvTechnicalStatsRecord\r\n}\r\n","function _isNativeFunction(fn) {\n  return Function.toString.call(fn).indexOf(\"[native code]\") !== -1;\n}\n\nmodule.exports = _isNativeFunction;","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nfunction _construct(Parent, args, Class) {\n  if (isNativeReflectConstruct()) {\n    module.exports = _construct = Reflect.construct;\n  } else {\n    module.exports = _construct = function _construct(Parent, args, Class) {\n      var a = [null];\n      a.push.apply(a, args);\n      var Constructor = Function.bind.apply(Parent, a);\n      var instance = new Constructor();\n      if (Class) setPrototypeOf(instance, Class.prototype);\n      return instance;\n    };\n  }\n\n  return _construct.apply(null, arguments);\n}\n\nmodule.exports = _construct;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nvar setPrototypeOf = require(\"./setPrototypeOf\");\n\nvar isNativeFunction = require(\"./isNativeFunction\");\n\nvar construct = require(\"./construct\");\n\nfunction _wrapNativeSuper(Class) {\n  var _cache = typeof Map === \"function\" ? new Map() : undefined;\n\n  module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {\n    if (Class === null || !isNativeFunction(Class)) return Class;\n\n    if (typeof Class !== \"function\") {\n      throw new TypeError(\"Super expression must either be null or a function\");\n    }\n\n    if (typeof _cache !== \"undefined\") {\n      if (_cache.has(Class)) return _cache.get(Class);\n\n      _cache.set(Class, Wrapper);\n    }\n\n    function Wrapper() {\n      return construct(Class, arguments, getPrototypeOf(this).constructor);\n    }\n\n    Wrapper.prototype = Object.create(Class.prototype, {\n      constructor: {\n        value: Wrapper,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    return setPrototypeOf(Wrapper, Class);\n  };\n\n  return _wrapNativeSuper(Class);\n}\n\nmodule.exports = _wrapNativeSuper;","/**\r\n * @see https://github.com/Microsoft/TypeScript/wiki/Breaking-Changes#extending-built-ins-like-error-array-and-map-may-no-longer-work\r\n */\r\nclass ChallengeCreateError extends Error {\r\n  constructor(m: string, public fileName: string) {\r\n    super(m)\r\n\r\n    // Set the prototype explicitly.\r\n    Object.setPrototypeOf(this, ChallengeCreateError.prototype)\r\n  }\r\n}\r\n\r\nexport { ChallengeCreateError }\r\n","import {\r\n  killHeaderNames,\r\n  weaponHeaderNames,\r\n  summaryHeaderNames,\r\n  technicalHeaderNames,\r\n  getGameVersionFromRawSummarySection\r\n} from \"./version/version-api\"\r\nimport { GameVersion } from \"./version/version-types\"\r\nimport {\r\n  CsvRawSectionContent,\r\n  CsvNamedSections,\r\n  ValidatedChallengeFile,\r\n  ParsedChallengeFile\r\n} from \"@fat-dash/domain/csv-etl/types\"\r\nimport { ChallengeCreateError } from \"@fat-dash/domain/csv-etl/ChallengeCreateError\"\r\nimport { parseChallengeFileNameOrThrow } from \"@fat-dash/domain/csv-etl/parse\"\r\n\r\nfunction getValidatedChallengeFile(\r\n  file: ParsedChallengeFile\r\n): ValidatedChallengeFile {\r\n  parseChallengeFileNameOrThrow(file.name)\r\n  const csvNamedSections = createCsvNamedSections(file)\r\n  const gameVersion = getGameVersionFromRawSummarySection(\r\n    csvNamedSections[\"Summary\"]\r\n  )\r\n  validateSectionsOrThrow(csvNamedSections, gameVersion, file.name)\r\n  return {\r\n    csvNamedSections,\r\n    gameVersion\r\n  }\r\n}\r\n\r\nfunction createCsvNamedSections(file: ParsedChallengeFile) {\r\n  if (file.content.length !== 4) throw new Error(\"Expected 4 CSV sections.\")\r\n  return {\r\n    Kill: file.content[0],\r\n    Weapon: file.content[1],\r\n    Summary: file.content[2],\r\n    Technical: file.content[3]\r\n  }\r\n}\r\n\r\nfunction validateSectionsOrThrow(\r\n  csvSections: CsvNamedSections,\r\n  gameVersion: GameVersion,\r\n  fileName: string\r\n) {\r\n  try {\r\n    validateKillSection(csvSections[\"Kill\"], gameVersion)\r\n    validateWeaponSection(csvSections[\"Weapon\"], gameVersion)\r\n    validateSummarySection(csvSections[\"Summary\"], gameVersion)\r\n    validateTechnicalSection(csvSections[\"Technical\"], gameVersion)\r\n  } catch (e) {\r\n    throw new ChallengeCreateError(\r\n      `${(e as Error).message || \"content parse error\"}`,\r\n      fileName\r\n    )\r\n  }\r\n}\r\n\r\nconst validateKillSection = (\r\n  csvSection: CsvRawSectionContent,\r\n  gameVersion: GameVersion\r\n) => _validateHeaderEqual(csvSection[0], killHeaderNames(gameVersion))\r\n\r\nconst validateWeaponSection = (\r\n  csvSection: CsvRawSectionContent,\r\n  gameVersion: GameVersion\r\n) => _validateHeaderEqual(csvSection[0], weaponHeaderNames(gameVersion))\r\n\r\nconst validateSummarySection = (\r\n  csvSection: CsvRawSectionContent,\r\n  gameVersion: GameVersion\r\n) => validateKeyValueSection(csvSection, summaryHeaderNames(gameVersion))\r\n\r\nconst validateTechnicalSection = (\r\n  csvSection: CsvRawSectionContent,\r\n  gameVersion: GameVersion\r\n) => validateKeyValueSection(csvSection, technicalHeaderNames(gameVersion))\r\n\r\nconst validateKeyValueSection = (\r\n  csvSection: CsvRawSectionContent,\r\n  sectionKeys: string[]\r\n) =>\r\n  csvSection.forEach((row, idx) => {\r\n    if (row.length > 2)\r\n      throw new Error(`csv validation: No valid key value section. \\\r\n            Expected one key and only one value column.`)\r\n\r\n    _validateKeyEqual(row[0], sectionKeys[idx])\r\n  })\r\n\r\nconst _validateHeaderEqual = (\r\n  headerActual: string[],\r\n  headerExpected: string[]\r\n) => {\r\n  if (\r\n    !(\r\n      headerActual.length === headerExpected.length &&\r\n      // do not make difference between undefined values null and \"\"\r\n      // implementation (up to this point papa parse) parses both as null\r\n      headerActual.every((v, i) =>\r\n        !headerExpected[i] ? !v : v === headerExpected[i]\r\n      )\r\n    )\r\n  )\r\n    throw new Error(\r\n      `CSV format not correct. Expected Header\\n${headerExpected}. \\\r\nactual is\\n${headerActual}`\r\n    )\r\n}\r\n\r\nconst _validateKeyEqual = (keyActual: string, keyExpected: string) => {\r\n  if (keyActual !== keyExpected)\r\n    throw new Error(`CSV format not correct. Expected key \"${keyExpected}\". \\\r\nActual is \"${keyActual}\".`)\r\n}\r\n\r\nexport { getValidatedChallengeFile }\r\n","import { Weapon } from \"@fat-dash/domain/csv-etl/types\"\r\nimport { CsvWeaponStatsRecord } from \"@fat-dash/domain/csv-etl/csv-record-types\"\r\n\r\nfunction mapWeaponsFromFile(\r\n  csvWeaponSectionRecords: CsvWeaponStatsRecord[]\r\n): Weapon[] {\r\n  return csvWeaponSectionRecords.map<Weapon>(\r\n    ({ weapon, shots, hits, damageDone, damagePossible }) => ({\r\n      weapon,\r\n      shots,\r\n      hits,\r\n      damageDone,\r\n      damagePossible\r\n    })\r\n  )\r\n}\r\n\r\nexport { mapWeaponsFromFile }\r\n","import { parseChallengeFileNameOrThrow } from \"./parse\"\r\nimport { mapChallengeFromFile } from \"./mapChallengeFromFile\"\r\nimport { mapKillFromFile } from \"./mapKillFromFile\"\r\nimport {\r\n  mapCsvTechnicalStatsRecord,\r\n  mapCsvSummaryStatsRecord,\r\n  mapCsvKillStatsRecords,\r\n  mapCsvWeaponStatsRecord\r\n} from \"./csv-record-map-props\"\r\nimport { getValidatedChallengeFile } from \"@fat-dash/domain/csv-etl/validate-csv\"\r\nimport {\r\n  Challenge,\r\n  ParsedChallengeFile,\r\n  AnemicWriteChallenge\r\n} from \"@fat-dash/domain/csv-etl/types\"\r\nimport { mapWeaponsFromFile } from \"@fat-dash/domain/csv-etl/mapWeaponsFromFile\"\r\n\r\n/**\r\n * Factory function to create a Challenge in the domain model given a parsed\r\n * csv file as user input\r\n * @param file parsed file\r\n */\r\nfunction createChallenge(file: ParsedChallengeFile): Challenge {\r\n  const valFile = getValidatedChallengeFile(file)\r\n  const fileName = parseChallengeFileNameOrThrow(file.name)\r\n  const out: AnemicWriteChallenge = {\r\n    ...mapChallengeFromFile(\r\n      mapCsvSummaryStatsRecord(\r\n        valFile.csvNamedSections[\"Summary\"],\r\n        valFile.gameVersion\r\n      ),\r\n      mapCsvTechnicalStatsRecord(\r\n        valFile.csvNamedSections[\"Technical\"],\r\n        valFile.gameVersion\r\n      ),\r\n      fileName\r\n    ),\r\n    /* Hide the subentities in domain layer and only expose the aggregate root\r\n    named Challenge. Repositories in infrastructure are the only place that \r\n    know of these internals. They cast the entity into an anemic form to be \r\n    able to save all its details */\r\n    kills: mapKillFromFile(\r\n      mapCsvKillStatsRecords(\r\n        valFile.csvNamedSections[\"Kill\"],\r\n        valFile.gameVersion\r\n      ),\r\n      fileName\r\n    ),\r\n    weapons: mapWeaponsFromFile(\r\n      mapCsvWeaponStatsRecord(\r\n        valFile.csvNamedSections[\"Weapon\"],\r\n        valFile.gameVersion\r\n      )\r\n    )\r\n  }\r\n  return out\r\n}\r\n\r\nexport { createChallenge }\r\n","function isPromise(p: any): p is Promise<any> {\r\n  return p.then && p.catch\r\n}\r\n\r\nconst delay = (milis: number) =>\r\n  new Promise<void>(resolve => setTimeout(resolve, milis))\r\n\r\nexport { isPromise, delay }\r\n","import { initFileReader } from \"@fat-dash/infrastructure/fs/read-file\"\r\nimport { createChallenge } from \"@fat-dash/domain/csv-etl/createChallenge\"\r\nimport { CreateChallengeResult, FileReadResult } from \"@fat-dash/app/types\"\r\nimport { delay } from \"@fat-dash/common/async\"\r\nimport { parseCsvSections } from \"@fat-dash/domain/csv-etl/parse\"\r\n\r\ntype WorkerContext = {\r\n  onmessage(this: Worker, ev: { data: File[] }): void\r\n  postMessage(message: CreateChallengeResult): void\r\n}\r\n\r\nconst workerCtx: WorkerContext = self as any\r\n\r\nworkerCtx.onmessage = async e => {\r\n  let pendingCount = 0\r\n  for (let idx = 0; idx < e.data.length; idx++) {\r\n    while (true) {\r\n      if (pendingCount <= PENDING_COUNT_MAX) {\r\n        initFileReader(e.data[idx], onFileReadResult)\r\n        pendingCount += 1\r\n        break\r\n      } else await delay(0)\r\n    }\r\n  }\r\n\r\n  function onFileReadResult(readResult: FileReadResult) {\r\n    pendingCount = Math.max(0, pendingCount - 1)\r\n    processFileReadResult(readResult)\r\n  }\r\n}\r\n\r\nfunction processFileReadResult(readResult: FileReadResult) {\r\n  if (readResult.errorMessage === null) {\r\n    try {\r\n      workerCtx.postMessage({\r\n        challenge: createChallenge({\r\n          content: parseCsvSections(readResult.fileContent),\r\n          name: readResult.fileName\r\n        }),\r\n        fileName: readResult.fileName\r\n      })\r\n    } catch (e) {\r\n      workerCtx.postMessage({\r\n        challenge: null,\r\n        fileName: readResult.fileName,\r\n        errorMessage: e.message\r\n      })\r\n    }\r\n  } else {\r\n    workerCtx.postMessage({\r\n      challenge: null,\r\n      fileName: readResult.fileName,\r\n      errorMessage: readResult.errorMessage\r\n    })\r\n  }\r\n}\r\n\r\nconst PENDING_COUNT_MAX = navigator.hardwareConcurrency\r\n"]}